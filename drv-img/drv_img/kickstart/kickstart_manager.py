import os
from pykickstart.version import makeVersion
from pykickstart.parser import KickstartParser, Script
from pykickstart.constants import KS_SCRIPT_POST, KS_SCRIPT_PRE

from drv_img.utils import run_cmd
from drv_img.core.global_config import GlobalConfig

KS_PATH = "/usr/share/anaconda/interactive-defaults.ks"
MOVE_PATH = "/_tmp"

INS_SHELL_SCRIPT = """\
# The content of this script is generated by drv-img
#!/bin/bash
set -x

RPM_PATH={}
if command -v rpm >/dev/null 2>&1; then
  for i in $(find $RPM_PATH -name "*.rpm"); do
    rpm -i $i --nodeps --force
  done
else
  for i in $(find $RPM_PATH -name "*.rpm"); do
    dnf install $i --releasever {} -y
  done
fi

KO_PATH={}
for i in $(find $KO_PATH -name "*.ko"); do
    if command -v rpm >/dev/null 2>&1; then
        mv $i /lib/modules/`uname -r`/updates/
        insmod  /lib/modules/`uname -r`/updates/$(basename $i .ko)
    fi
    modprobe -a $(basename $i .ko)
done

depmod -a

"""

RM_SHELL_SCRIPT = """\
# The content of this script is generated by drv-img
#!/bin/bash
set -x
rm -rf {}

"""


class KickManager:

    def __init__(self, install_img_path, rpm_list, ko_list):
        self._install_path = install_img_path
        self._rpm_list = rpm_list
        self._ko_list = ko_list

    def modify_kickstart(self, kck_file, output_file):
        ks_content = self._read_kickstart_file(kck_file)

        ks_parser = KickstartParser(makeVersion())
        ks_parser.readKickstartFromString(ks_content)
        self._process_file_sections(ks_parser)

        self._write_to_output_file(output_file, ks_parser.handler)

    def _process_file_sections(self, ks_parser):
        self._add_pre_section(ks_parser)
        self._add_post_section(ks_parser)

    def _add_pre_section(self, ks_parser):
        content = INS_SHELL_SCRIPT.format(MOVE_PATH, GlobalConfig.VERSION_ID, MOVE_PATH)
        self._add_script_to_section(ks_parser,
                                    content,
                                    inChroot=False,
                                    type=KS_SCRIPT_PRE)

    def _add_post_section(self, ks_parser):
        content = "# The content of this script is generated by drv-img\n \
        mv {} /mnt/sysimage{}".format(MOVE_PATH, MOVE_PATH)
        self._add_script_to_section(ks_parser,
                                    content,
                                    inChroot=False,
                                    type=KS_SCRIPT_POST)
        chroot_content = INS_SHELL_SCRIPT.format(MOVE_PATH, GlobalConfig.VERSION_ID, MOVE_PATH)
        chroot_content += RM_SHELL_SCRIPT.format(MOVE_PATH)
        self._add_script_to_section(ks_parser,
                                    chroot_content,
                                    inChroot=True,
                                    type=KS_SCRIPT_POST)

    def move_driver(self):
        # copy ko and rpm to tmp dir for furture ks usage
        tmp_path = self._install_path + MOVE_PATH
        run_cmd.mkdir_chain(tmp_path)
        for ko in self._ko_list:
            run_cmd.cp_file(ko, tmp_path)

        for rpm in self._rpm_list:
            run_cmd.cp_file(rpm, tmp_path)

    def _add_script_to_section(self,
                               ks_parser,
                               content,
                               inChroot,
                               lineno=0,
                               interp='/bin/bash',
                               type=KS_SCRIPT_POST):
        """Adds a script to kickstart parser"""
        new_script = Script(content,
                            interp=interp,
                            inChroot=inChroot,
                            lineno=lineno,
                            type=type)
        ks_parser.handler.scripts.append(new_script)

    def _read_kickstart_file(self, kck_file):
        """Reads and returns content of a kickstart file"""
        if os.path.exists(kck_file) is False:
            print(f"Kickstart file not found: {kck_file} try to create it")
            os.mknod(kck_file)
        with open(kck_file, 'r') as ks:
            return ks.read()

    def _write_to_output_file(self, output_file, handler):
        """Writes to output file"""
        try:
            with open(output_file, 'w') as f:
                f.write(handler.__str__())
        except IOError:
            print(f"Error writing to output file: {output_file}")
            
        with open(output_file, 'r+') as f:
            contents = f.readlines()
            f.seek(0)
            for line in contents:
              if not line.startswith('bootloader'):
                f.write(line)
            f.truncate()
